## **1) 서비스/유틸에 로직 흩뿌리기 → 엔티티/VO/DTO가 스스로 판단/계산**

### **(안티)**

```java
// 할인 규칙이 Service에 떠돌아다님 (캡슐화 붕괴)
class OrderService {
    int calcPayable(int unitPrice, int qty, int membershipLevel) {
        int base = unitPrice * qty;
        if (membershipLevel >= 3) base *= 0.9;  // VIP 10% 할인
        return base;
    }
}
```

### **(대안)**

```java
// 규칙을 도메인 객체 안으로 (응집↑, 변경 영향 지역화)
class Order {
    private final int unitPrice;
    private final int qty;
    private final Membership membership;

    Order(int unitPrice, int qty, Membership membership) {
        if (unitPrice <= 0 || qty <= 0) throw new IllegalArgumentException();
        this.unitPrice = unitPrice; this.qty = qty; this.membership = membership;
    }

    public int payable() { // 의미 있는 동작 메서드
        int base = unitPrice * qty;
        return membership.applyDiscount(base);
    }
}

enum Membership {
    NORMAL { int applyDiscount(int base){ return base; } },
    VIP    { int applyDiscount(int base){ return (int)(base * 0.9); } };
    abstract int applyDiscount(int base);
}
```

---

## **2) 거대한 if/else 분기 → 전략 패턴/Enum 위임**

### **(안티)**

```java
class ShippingFeeCalculator {
    int calc(String type, int weight) {
        if ("STANDARD".equals(type)) return 3000 + weight * 10;
        else if ("EXPRESS".equals(type)) return 6000 + weight * 20;
        else if ("SAME_DAY".equals(type)) return 10000 + weight * 30;
        throw new IllegalArgumentException("unknown type");
    }
}
```

### **(대안: 전략)**

```java
interface ShippingPolicy { int fee(int weight); }

class Standard implements ShippingPolicy { public int fee(int w){ return 3000 + w*10; } }
class Express  implements ShippingPolicy { public int fee(int w){ return 6000 + w*20; } }
class SameDay  implements ShippingPolicy { public int fee(int w){ return 10000 + w*30; } }

class ShippingFeeCalculator {
    private final ShippingPolicy policy;
    ShippingFeeCalculator(ShippingPolicy policy){ this.policy = policy; }
    int calc(int weight){ return policy.fee(weight); }
}

// 사용
// new ShippingFeeCalculator(new Express()).calc(120);
```

### **(대안: Enum 위임)**

```java
enum ShippingType {
    STANDARD(w -> 3000 + w*10),
    EXPRESS (w -> 6000 + w*20),
    SAME_DAY(w ->10000 + w*30);

    private final java.util.function.IntUnaryOperator rule;
    ShippingType(java.util.function.IntUnaryOperator rule){ this.rule = rule; }
    int fee(int weight){ return rule.applyAsInt(weight); }
}

// 사용: ShippingType.EXPRESS.fee(120);
```

---

## **3) Setter로 불완전 객체 만들기 → 생성자·팩토리에서 유효성 보장**

### **(안티)**

```java
class Account {
    private String email;
    private String password;
    // 실수로 비밀번호 세팅 누락 시 불완전 객체 생성
    void setEmail(String e){ this.email = e; }
    void setPassword(String p){ this.password = p; }
}
```

### **(대안)**

```java
class Account {
    private final String email;
    private final String password;

    private Account(String email, String password) {
        if (email == null || !email.contains("@")) throw new IllegalArgumentException();
        if (password == null || password.length() < 8) throw new IllegalArgumentException();
        this.email = email; this.password = password;
    }

    public static Account of(String email, String rawPassword) {
        return new Account(email, hash(rawPassword));
    }

    private static String hash(String raw){ return Integer.toHexString(raw.hashCode()); }
}
```

---

## **4) Optional을 필드에 사용 → 반환 타입에서만 사용(orElseThrow 등)**

### **(안티)**

```java
// JPA/직렬화/불필요 래핑 문제 유발
class Profile {
    private Optional<String> nickname; // ❌
}
```

### **(대안 1: 필드는 nullable, 반환은 Optional)**

```java
class Profile {
    private String nickname; // null 허용
    public Optional<String> nickname() {
        return Optional.ofNullable(nickname);
    }
}
```

### **(대안 2: 컬렉션은 빈 컬렉션 활용)**

```java
class Box {
    private final List<String> tags = new ArrayList<>();
    public List<String> tags() { return List.copyOf(tags); } // 읽기전용 뷰
}
```

### **(대안 3 사용 시 의도 표현)**

```java
String nick = profile.nickname().orElse("손님");
String must = profile.nickname().orElseThrow(() -> new IllegalStateException("닉네임 없음"));
```

---

## **5) Checked 전파 남발 → 의미 있는 Unchecked 변환**

### **(안티)**

```java
class FileLoader {
    // 호출자마다 IOException 전파 → 서비스 전체에 try/throws 퍼짐
    String read(String path) throws IOException {
        return new String(Files.readAllBytes(Path.of(path)));
    }
}
```

### **(대안)**

```java
// 도메인 의미가 드러나는 런타임 예외
class DocumentNotFoundException extends RuntimeException {
    DocumentNotFoundException(String path, Throwable cause){
        super("문서를 찾을 수 없습니다: " + path, cause);
    }
}

class FileLoader {
    String readOrThrow(String path) {
        try {
            return Files.readString(Path.of(path));
        } catch (IOException e) {
            throw new DocumentNotFoundException(path, e); // 의미 부여하여 변환
        }
    }
}

// 경계(컨트롤러)에서 최종 매핑
//@ExceptionHandler(DocumentNotFoundException.class)
//ResponseEntity<?> handle(DocumentNotFoundException ex){ return ResponseEntity.notFound().build(); }
```

## **한 줄 요약**

- **규칙은 객체 안으로**, **분기는 전략/Enum으로**, **생성 시점에 완전성 보장**, **Optional은 반환에서만**, **예외는 의미 있는 Unchecked로 변환**.
