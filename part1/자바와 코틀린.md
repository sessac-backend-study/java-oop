## 자바와 코틀린의 등장 배경

### 자바

- 1995년 썬 마이크로시스템즈에서 발표된 객체지향 언어
- "한 번 작성하면 어디서나 실행된다(Write Once, Run Anywhere)"라는 철학으로 JVM 위에서 동작
- 기업 서버, 금융권, 안드로이드 앱 개발 등 다양한 분야에서 표준처럼 자리 잡았다
- 하지만 세월이 지나면서 문법이 장황하고, null 처리 문제와 같은 런타임 오류가 빈번히 발생하는 등 한계가 드러났다
- 자바 8 이후 람다, 스트림, Optional 같은 기능이 추가됐지만, 근본적으로는 여전히 많은 보일러플레이트 코드와 안전성 문제가 남아 있었다

### 코틀린

- 2011년 JetBrains가 발표한 언어로, JVM 위에서 실행되며 자바와 100% 호환된다
- 자바의 한계를 보완하는 것을 목표로 만들어졌으며, 간결함/안전성/표현력을 핵심 가치로 한다
- null 안정성, 데이터 클래스, 확장 함수, 코루틴 등 현대적 언어 기능을 제공
- 2017년 구글이 안드로이드 공식 언어로 채택하면서 빠르게 확산되었고, 최근에는 서버 사이드(스프링 부트 등)에서도 적극적으로 사용되고 있다

<br>

## 1. Null 처리

- **자바에서는 `NullPointerException`이 자주 발생**
    - 자바 객체 참조는 기본적으로 null을 허용한다
    - 방어적 코드를 넣지 않으면 런타임에서 NPE 발생
    
    ```java
    // Java
    if (user != null && user.getAddress() != null) {
        String city = user.getAddress().getCity();
    }
    ```
    

- **자바 8의 Optional은 제한적인 해결책**
    - `Optional<T>`는 null 대신 값이 있을 수도/없을 수도 있음을 표현한다.
    - 그러나 권장되는 사용처는 반환 타입뿐, 필드나 매개변수에는 쓰지 않는 게 일반적이다.
    - 컬렉션과 혼합되면 오히려 복잡성이 커지고, 메모리 오버헤드도 발생할 수 있다.
        - 필드나 매개변수에 쓰면 코드가 지나치게 복잡해지고, 컬렉션과 섞이면 읽기가 더 어려워진다.
        - 또한 내부 객체를 감싸기 때문에 메모리 사용량도 늘어난다.

- **코틀린은 언어 차원에서 null 안정성을 제공**
    - 타입에 null 허용 여부를 명시 (`String` vs `String?`)
    - 안전 호출 `?.`, 기본값 제공 `?:`으로 런타임 오류를 줄인다.
    - not-null을 단언하는 `!!`는 위험하니 조심스럽게 사용해야 한다.
    
    ```kotlin
    // Kotlin
    val name: String? = user?.name
    val safeName: String = name ?: "guest"
    ```
    
    - 코틀린 null 관련 연산자
        - 안전 호출 연산자 (`?.`)
            
            : 객체가 null이면 그냥 null을 반환, null이 아니면 속성/메서드를 호출
            
            ```kotlin
            val user: User? = getUser()
            val city = user?.address?.city   // user가 null이면 city도 null
            ```
            
        - 엘비스 연산자 (`?:`)
            
            : null일 때의 기본값 설정
            
            ```kotlin
            val name: String? = user?.name
            val safeName = name ?: "Guest"   // name이 null이면 "Guest" 반환
            ```
            
        - non-null 단언 (`!!`)
            
            : 절대 null이 아님을 단언
            
            ```kotlin
            val name: String? = null
            val length = name!!.length   // NPE 발생
            ```
            
        - let + 안전 호출
            
            : null이 아닐 때만 블록을 실행
            
            ```kotlin
            val user: User? = getUser()
            user?.let {
                println("사용자 이름: ${it.name}")
                println("사용자 나이: ${it.age}")
            }
            ```
            
<br>

## 2. 데이터 클래스

- **자바에서는 DTO/VO에 보일러플레이트 코드가 많음**
    - getter, setter, equals, hashCode, toString 등의 코드를 직접 작성해야 한다.
    - 보완책으로 Lombok 라이브러리를 많이 쓰지만 빌드 의존성이 생기고, IDE 지원이 불완전할 수 있다.
        - 빌드 툴과 IDE 플러그인에 의존해야 해서 환경에 따라 인식이 안 되거나, 디버깅할 때 실제 코드가 보이지 않는 불편함이 있다.
    
    ```java
    // Java
    public class User {
        private Long id;
        private String name;
    
        // getter, setter, equals, hashCode, toString 모두 필요
    }
    ```
    
- **코틀린의 data class는 보일러플레이트가 적음**
    - `data class User(val id: Long, val name: String)` 한 줄로 끝
    - equals, hashCode, toString, copy까지 자동으로 생성한다.
    - 불변 객체 패턴을 구현하기도 쉽다.
        - 객체가 한 번 만들어지면 내부 값을 바꿀 수 없도록 설계하는 방식
        - 값이 의도치 않게 변경되는 버그를 막을 수 있고, 멀티스레드 환경에서 안전
        - 코틀린의 `data class`와 `copy()`는 이런 불변 객체를 쉽게 다룰 수 있게 함
          - copy(): 원본 객체는 그대로 두고, 특정 값만 바꾼 새 객체를 만들어줌
    
    ```kotlin
    // Kotlin
    data class User(val id: Long, val name: String)
    val user1 = User(1, "Alice")
    val user2 = user1.copy(name = "Bob")  // 불변 객체 기반 복사
    ```

<br>

## 3. 함수형 스타일

- **자바의 스트림 API는 장황함**
    - 함수형 프로그래밍을 지원하지만 문법적으로 무겁다.
        - 자바 스트림의 체이닝 구조는 유용하지만, 코드가 길어지고 가독성이 떨어지기 쉬움
    
    ```java
    // Java
    List<User> users = ...;
    
    List<String> names = users.stream()
        .filter((User u) -> u.isActive())   // 타입(User)을 명시해야 하기도 함
        .map((User u) -> u.getName())       // 타입 반복
        .collect(Collectors.toList());
    ```
    
- **코틀린의 컬렉션 API는 직관적**
    - 자바는 stream을 호출해야 쓸 수 있는 함수형 API(`filter`, `map`, `reduce`  등의 고차 함수)를 코틀린 컬렉션에서는 기본으로 제공
    - 람다 문법이 간결해 가독성이 좋다
        - `filter { }`, `map { }`처럼 불필요한 타입 선언 없이 쓸 수 있음
        - 람다에서 매개변수를 `it`으로 바로 쓸 수 있어 짧고 직관적
    
    ```kotlin
    val users: List<User> = ...
    
    val names = users
        .filter { it.active }   // it은 User 타입으로 추론됨
        .map { it.name }        // 타입을 안 써도 자동으로 User.name
    ```

<br>

## 4. 확장 함수

> 기존 클래스를 수정하지 않고, 새로운 함수를 덧붙여 사용할 수 있는 기능
> 
- **자바에서는 유틸리티 클래스를 만들어야 함**
    - static 메서드로 유틸리티 기능을 제공하는 것은 객체지향적이지 않고 코드가 분산되게 된다.
    
    ```java
    // Java
    public class StringUtils {
        public static boolean isEmail(String input) {
            return input.contains("@");
        }
    }
    ```
    
- **코틀린은 확장 함수로 기존 클래스에 기능을 추가함**
    - 확장 함수를 정의하면 마치 해당 클래스의 내장 메서드처럼 호출 가능
    - 실제 클래스 파일 안에 들어가는 건 아니고, 컴파일 시점에 정적 메서드 호출로 변환
        
        예시) `StringExtensions.isEmail("[test@example.com](mailto:test@example.com)")`
        
    - 이런 식으로 자주 쓰이는 로직을 확장 함수로 묶으면 코드가 깔끔해지고, 도메인에 맞는 언어처럼 쓸 수 있다.
    - 유틸 확장 함수를 위한 별도의 파일
    
    ```kotlin
    // Kotlin
    
    // utils/StringExtensions.kt
    package com.example.utils
    
    fun String.isEmail(): Boolean = this.contains("@")
    ```

<br>

## 5. 불변성과 안전성

- **자바는 기본적으로 가변 객체 중심**
    - 필드를 변경할 수 있는 setter 패턴이 일반적이지만, 동시성 환경에서 데이터 불일치의 위험이 크다.

- **코틀린은 불변성을 지향**
    - `val`은 **읽기 전용 변수**로, 불변
    - `var`는 **변경 가능한 변수**
    - 기본적으로 `val`을 쓰고, 예외적으로 상태 변화를 의도할 때만 `var`를 쓰는 게 권장된다.
    - 이렇게 하면 멀티스레드/코루틴 환경에서도 데이터가 중간에 바뀌어 생기는 오류를 줄일 수 있다.

<br>

## 6. 스프링 부트와 코틀린

- **자바에서는 의존성 주입에 보일러플레이트 코드가 많음**
    - 생성자 주입을 쓰려면 롬복 @RequiredArgsConstructor 등을 조합해야 한다.
    
    ```java
    // Java
    @Service
    @RequiredArgsConstructor
    public class UserService {
        private final UserRepository userRepository;
    }
    
    ```
    
- **코틀린은 이를 기본 문법만으로 해결할 수 있음**
    - 생성자에 `private val`을 선언하면 불변 의존성이 자동 주입
    
    ```kotlin
    // Kotlin
    @Service
    class UserService(private val userRepository: UserRepository)
    ```
    
    - 주 생성자(primary constructor)의 파라미터 선언
    - 동시에 `private val`이나 `private var`를 붙이면 클래스 프로퍼티까지 자동 생성
    - 즉 생성자 주입 + 필드 선언 + 초기화를 한 줄에 해결

- 따라서 롬복 의존성을 줄이고, 프레임워크 코드의 동작 방식보다 비즈니스 로직에 집중할 수 있다.

<br>

## 7. 자바와 코틀린의 상호운용성

- **기존 자바 코드와 라이브러리를 그대로 사용 가능**
    - 코틀린도 JVM 바이트코드로 컴파일되므로, 자바와 같이 JVM 위에서 실행된다.
    - 따라서 스프링, 하이버네이트, 구글 라이브러리 등 자바 생태계를 그대로 활용할 수 있다.
    
    ```java
    // Java
    public interface UserRepository {
        User findById(Long id);
    }
    ```
    
    ```kotlin
    // Kotlin
    val repo: UserRepository = ...
    val user = repo.findById(1L)  // 자바 코드 그대로 호출 가능
    ```
    
- **코드베이스를 점진적으로 마이그레이션할 수 있음**
    - 기존 자바 코드와 혼용 가능하므로, 프로젝트 전체를 한 번에 코틀린으로 옮길 필요가 없다.
    - 기존 모듈은 유지하면서 새로운 기능은 코틀린으로 작성 가능

<br>

## 8. 비동기와 코루틴

- **자바는 비동기 처리를 위해 CompletableFuture, 리액티브 스트림을 사용**
    - 강력하긴 하지만 콜백 체인이 중첩되면서 코드가 복잡해지고, 에러 처리도 직관적이지 않다.
    
    ```java
    import java.util.concurrent.CompletableFuture;
    
    public class CompletableFutureExample {
        public static void main(String[] args) {
            CompletableFuture.supplyAsync(() -> {
                // 1. API 호출
                return fetchUser();
            }).thenCompose(user -> 
                CompletableFuture.supplyAsync(() -> {
                    // 2. DB 조회
                    return fetchOrders(user);
                })
            ).thenCompose(orders -> 
                CompletableFuture.supplyAsync(() -> {
                    // 3. 주문 검증
                    return validateOrders(orders);
                })
            ).thenAccept(validOrders -> {
                // 4. 결과 출력
                System.out.println("유효한 주문: " + validOrders);
            }).exceptionally(ex -> {
                // 예외 처리
                System.err.println("에러 발생: " + ex.getMessage());
                return null;
            });
        }
    
        static String fetchUser() {
            return "userA";
        }
        static String fetchOrders(String user) {
            return "orders for " + user;
        }
        static String validateOrders(String orders) {
            if (orders.contains("error")) throw new RuntimeException("검증 실패");
            return "valid " + orders;
        }
    }
    ```

- **코틀린의 코루틴**
    - `suspend` 함수 → 일시 중단 (예: 네트워크 요청, DB 조회)
    - `async` → 비동기 실행
    - `await` → 실행이 끝날 때까지 기다리고, 결과를 꺼내옴
    - 덕분에 동기 코드처럼 직관적으로 작성하면서도 실제로는 비동기로 동작한다.
        
        ```kotlin
        import kotlinx.coroutines.*
        
        fun main() = runBlocking {
            val deferred = async { fetchData() }
            val result = deferred.await()
            println("Result: $result")
        }
        
        suspend fun fetchData(): String {
            delay(1000)
            return "data"
        }
        ```

<br>

## 결론

기본적으로 자바보다 훨씬 간결하다.

- **Null 안정성** → 런타임 에러 감소
- **데이터 클래스 / 확장 함수** → 반복 코드 제거
- **불변성 중심** → 멀티스레드 안정성 확보
- **코루틴** → 비동기 코드 단순화

자바 생태계 라이브러리를 그대로 쓸 수 있어, 점진적으로 도입 가능하기 때문에 많은 프로젝트에서 마이그레이션을 하고 있는 것으로 보인다.

<br>

## 마이그레이션 시 참고하면 좋을 자료
[우당탕탕 Kotlin 전환기](https://dealicious-inc.github.io/2022/08/29/kotlin-converting.html)

[Java야…, 우리 그만 헤어져. Kotlin으로 환승연애 | 우아한형제들 기술블로그](https://techblog.woowahan.com/22586/)
